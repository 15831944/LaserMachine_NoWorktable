// HalconWnd.cpp : implementation file
//

#include "stdafx.h"
#include "HalconWnd.h"
#include "DeviceCameraDahengMER.h"
#include "DeviceCameraGeneralGE.h"
#include "CDlgDevCfgTabCamera.h"
#include "DeviceCardWorktable.h"
#include "DlgCameraPositionSetRealMarkPoint.h"
#include "DlgSetParaCamera.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//存标准mark圆尺寸
HObject g_hoModelCircleImage;
HTuple	g_hvCircleRadiusPixel = 0;

//Dxf相机窗口旋转，偏移
CPointF g_ptDxfTranslate = CPointF();
double g_fDxfRotate = 0;

//标定
HObject  ho_Map;
HTuple  hv_CameraParameters, hv_CameraPose, hv_CameraParametersChanged;


// Helper function to get client rect with possible
// modification by adding scrollbar width/height.
static void GetClientRectSB(CWnd* pWnd, CRect& rect)
{
	ASSERT(pWnd != NULL);

	CRect winRect;
	pWnd->GetWindowRect(&winRect);
	pWnd->ScreenToClient(&winRect);

	pWnd->GetClientRect(&rect);

	int cxSB = ::GetSystemMetrics(SM_CXVSCROLL);
	int cySB = ::GetSystemMetrics(SM_CYHSCROLL);

	if (winRect.right >= (rect.right + cxSB))
		rect.right += cxSB;
	if (winRect.bottom >= (rect.bottom + cySB))
		rect.bottom += cySB;
}


/////////////////////////////////////////////////////////////////////////////
// CHalconWnd
CHalconWnd::CHalconWnd()
{
	//Scroll
	m_attachWnd = NULL;
	m_pageSize = CSize(0, 0);
	m_displaySize = CSize(0, 0);
	m_scrollPos = CSize(0, 0);
	//Image
	m_hWindow = NULL;
	m_nImageWidth = 2592;
	m_nImageHeight = 1944;
	//Zoom
	m_dbZoomFactor = 1.0;
	m_bZoom = FALSE;
	m_nZoomWidth = m_nImageWidth;
	m_nZoomHeight = m_nImageHeight;
	//Draw
	m_bDrawingArea = FALSE;
	//DevCam
	m_pDevCam = NULL;
	//图像处理
	//m_bTestCreateModel = FALSE;
	//m_bTestMatchModel = FALSE;
	m_bTestFindCircleHand = FALSE;
	m_bTestFindCircles = FALSE;
	m_bCameraMoveHand = TRUE;
	m_bCameraMove = TRUE;
	m_hvScaleMin = 0.9;
	m_hvScaleMax = 1.1;
	m_hvMinScore = 0.7;

	//标定
//Calibration 01: Code generated by Calibration 01
	hv_CameraParameters.Clear();
	hv_CameraParameters[0] = "area_scan_division";
	hv_CameraParameters[1] = 0.00933771;
	hv_CameraParameters[2] = -1921.84;
	hv_CameraParameters[3] = 2.19576e-006;
	hv_CameraParameters[4] = 2.2e-006;
	hv_CameraParameters[5] = 1302.83;
	hv_CameraParameters[6] = 904.669;
	hv_CameraParameters[7] = 2592;
	hv_CameraParameters[8] = 1944;
	hv_CameraPose.Clear();
	hv_CameraPose[0] = -0.0782029;
	hv_CameraPose[1] = -0.0543831;
	hv_CameraPose[2] = 0.252205;
	hv_CameraPose[3] = 359.515;
	hv_CameraPose[4] = 359.986;
	hv_CameraPose[5] = 263.051;
	hv_CameraPose[6] = 0;
	ChangeRadialDistortionCamPar("adaptive", hv_CameraParameters, 0, &hv_CameraParametersChanged);
	GenRadialDistortionMap(&ho_Map, hv_CameraParameters, hv_CameraParametersChanged,
		"bilinear");


}

CHalconWnd::~CHalconWnd()
{
}

// ======================================================================== 
// ======================================================================== 	
// BEGIN_MESSAGE_MAP - MFC uses message maps to map direct messages to 
//                     distinct class member functions. They allow messages 
//                     to be handled by the most appropriate C++ object 
//                     - application, document, view, and so on. You can map a
//	                   single message or a range of messages - usually 
//                     generated by menus, toolbar buttons, or accelerators.
//                     Message maps also supply a way to update user-interface
//                     objects (such as menus and toolbar buttons), enabling
//                     or disabling them to suit the current context.
//
int WM_DISP = RegisterWindowMessage(_T("MYDISP"));


BEGIN_MESSAGE_MAP(CHalconWnd, CWnd)
	//{{AFX_MSG_MAP(CHalconWnd)
	ON_WM_CREATE()
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	//}}AFX_MSG_MAP
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_WM_CLOSE()
	ON_REGISTERED_MESSAGE(WM_DISP, &CHalconWnd::OnDisp)
	ON_MESSAGE(WM_GET_IMAGE, &CHalconWnd::OnGetImage)
	ON_MESSAGE(WM_SHOW_CONTOUR, &CHalconWnd::OnShowContour)
	ON_MESSAGE(WM_SHOW_TEXT, &CHalconWnd::OnShowText)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CHalconWnd message handlers

int CHalconWnd::OnCreate(LPCREATESTRUCT cs) 
{
	if (CWnd::OnCreate(cs) == -1)
		return -1;

	//multiThread
	m_bThreadsAreRunning = FALSE;
	m_pThImgProc = NULL;
	m_pThImgAcq = NULL;

	InitializeCriticalSection(&newImageMutex);
	InitializeCriticalSection(&resultDataMutex);

	// set up event handles to synchronize threads 

	// Note that the mapping of CreateEvent to CreateEventA/W
	// is disabled when including HALCON/C++, due to a name conflict
	// with the HALCON Operator CreateEvent.
#if defined(_UNICODE) || defined(__UNICODE)
	hdFindDone = CreateEventW(NULL, FALSE, FALSE, NULL);
	fgStopEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
	newImageEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
	newResultEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
	containerIsFreeEvent = CreateEventW(NULL, FALSE, TRUE, NULL);;
#else
	hdFindDone = CreateEventA(NULL, FALSE, FALSE, NULL);
	fgStopEvent = CreateEventA(NULL, TRUE, FALSE, NULL);
	newImageEvent = CreateEventA(NULL, FALSE, FALSE, NULL);
	newResultEvent = CreateEventA(NULL, FALSE, FALSE, NULL);
	containerIsFreeEvent = CreateEventA(NULL, FALSE, TRUE, NULL);;
#endif

	ClearContourMask();
	ClearStringMask();
	ResetEvent(fgStopEvent);

	//相机初始化
	if (NULL != m_pDevCam)
	{
		delete m_pDevCam;
		m_pDevCam = NULL;
	}

	//读ini并动态生成相机硬件类
	switch (ReadDevCameraName())
	{
	case CAMERA_NAME::CAMERA_NONE:
		m_pDevCam = NULL;
		break;
	case CAMERA_NAME::CAMERA_GENERAL_GE:
		m_pDevCam = new CDeviceCameraGeneralGE;
		break;
	case CAMERA_NAME::CAMERA_DAHENG_MER:
		m_pDevCam = new CDeviceCameraDahengMER;
		break;
	case CAMERA_NAME::CAMERA_2:
		m_pDevCam = NULL;
		break;
	default:
		m_pDevCam = NULL;
		break;
	}

	if (NULL == m_pDevCam)
	{
		AfxMessageBox(_T("相机初始化失败"));
		m_bThreadsAreRunning = FALSE;
		return 0;
	}

	if (FALSE == m_pDevCam->OpenDevCamera())
	{
		delete m_pDevCam;
		m_pDevCam = NULL;
		AfxMessageBox(_T("相机初始化失败"));
		m_bThreadsAreRunning = FALSE;
		return 0;
	}

	m_nImageWidth = m_pDevCam->GetImgWidth();
	m_nImageHeight = m_pDevCam->GetImgHeight();


	InitHalconWnd(0, 0, m_nImageWidth, m_nImageHeight);

	return 0;
}

void CHalconWnd::InitHalconWnd(HTuple x, HTuple y, HTuple w, HTuple h)
{
	try
	{
		if (NULL != m_hWindow)
			HalconCpp::CloseWindow(m_hWindow);
		SetWindowAttr("background_color", "black");
		SetWindowAttr("border_width", 0);
		//SetCheck("~father");
		OpenWindow(x, y, w, h, (Hlong)m_hWnd, "visible", "", &m_hWindow);
		//SetCheck("father");
		HDevWindowStack::Push(m_hWindow);

		SetPart(m_hWindow, -1, -1, -1, -1);
		SetColor(m_hWindow, "green");
		SetLineWidth(m_hWindow, 1);

	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("打开Halcon窗口失败"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
	}
}

BOOL CHalconWnd::LoadImageFromHObject(HObject ho_Img)
{
	//读入图像数据
	try
	{
		m_hoImage = ho_Img;
	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("加载图像失败"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		return FALSE;
	}

	//获取图像高宽
	try
	{
		GetImageSize(m_hoImage, &m_nImageWidth, &m_nImageHeight);
	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("获取图像尺寸失败"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		return FALSE;
	}

	return TRUE;
}

BOOL CHalconWnd::LoadImageFromLocal(LPCSTR szImagePath)
{
	
	//读入图像数据
	try
	{
		ReadImage(&m_hoImage,szImagePath);
	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("加载图像失败"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		return FALSE;
	}

	//获取图像高宽
	try
	{
		GetImageSize(m_hoImage, &m_nImageWidth, &m_nImageHeight);
	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("获取图像尺寸失败"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		return FALSE;
	}

	return TRUE;
}

BOOL CHalconWnd::LoadImageFromBitmap(HTuple hv_ImageWidth, HTuple hv_ImageHeight, BYTE* pImageBuffer)
{
	//读入图像数据
	try
	{
		GenImage1(&m_hoImage, "byte", (HTuple)hv_ImageWidth, (HTuple)hv_ImageHeight, (long)pImageBuffer);
	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("加载图像失败"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		return FALSE;
	}

	//获取图像高宽
	try
	{
		GetImageSize(m_hoImage, &m_nImageWidth, &m_nImageHeight);
	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("获取图像尺寸失败"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		return FALSE;
	}

	return TRUE;

}


BOOL CHalconWnd::DisImage(HObject ho_Img)
{
	//设置当前显示范围
	try
	{
		//SetPart(m_hWindow, 0, 0, m_nImageHeight, m_nImageWidth);
		SetPart(m_hWindow, -1, -1, -1, -1);
	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("设置显示范围出错"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		return FALSE;

	}

	try
	{
		DispObj(ho_Img, m_hWindow);
	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("显示图像出错"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		return FALSE;
	}

	//缩放1.0倍
	this->Zoom(m_dbZoomFactor);
	return TRUE;

}

BOOL CHalconWnd::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt) 
{
	if(m_bDrawingArea)
		return FALSE;

	if(zDelta < 0)
		return this->ZoomOut();
	else
		return this->ZoomIn();

}

BOOL CHalconWnd::DrawRectangle1()
{
	if(m_bDrawingArea)
		return FALSE;
	m_bDrawingArea = TRUE;
	
	//HTuple Row1,Column1,Row2,Column2;
	try
	{
		HalconCpp::DrawRectangle1(m_hWindow, &drawRectRow1, &drawRectColumn1, &drawRectRow2, &drawRectColumn2);

		//HalconCpp::DrawRectangle1(m_hWindow, &Row1, &Column1, &Row2, &Column2);
		//DrawRectangle1Mod(m_hWindow, 100, 100, 400, 400, &Row1, &Column1, &Row2, &Column2);
		//DrawRectangle1Mod(m_hWindow, Row1, Column1, Row2, Column2, &Row1, &Column1, &Row2, &Column2);
		//GenRectangle1(&m_hoImageSelected, Row1, Column1, Row2, Column2);	
	}
	catch (HException & exception)
	{
		//AfxMessageBox(_T("画矩形失败"));
		AfxMessageBox(exception.ErrorMessage());
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		//return FALSE;
	}

	m_bDrawingArea = FALSE;
	return TRUE;
}
BOOL CHalconWnd::DrawRectangle2()
{
	if (m_bDrawingArea)
		return FALSE;
	m_bDrawingArea = TRUE;

	HTuple Row, Column, Phi, Length1, Length2;
	try
	{
		HalconCpp::DrawRectangle2(m_hWindow, &Row, &Column, &Phi, &Length1, &Length2);
	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("画斜矩形失败"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		return FALSE;
	}

	m_bDrawingArea = FALSE;
	return TRUE;
}
BOOL CHalconWnd::DrawCircle()
{
	if(m_bDrawingArea)
		return FALSE;
	m_bDrawingArea = TRUE;

	HTuple Row,Column,Radius;
	try
	{
		HalconCpp::DrawCircle(m_hWindow, &Row, &Column, &Radius);
	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("画圆形失败"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		return FALSE;
	}

	m_bDrawingArea = FALSE;
	return TRUE;
}
BOOL CHalconWnd::DrawEllipse()
{
	if (m_bDrawingArea)
		return FALSE;
	m_bDrawingArea = TRUE;

	HTuple Row, Column, Phi, Radius1, Radius2;
	try
	{
		HalconCpp::DrawEllipse(m_hWindow, &Row, &Column, &Phi, &Radius1, &Radius2);
	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("画椭圆失败"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		return FALSE;
	}

	m_bDrawingArea = FALSE;
	return TRUE;
}
BOOL CHalconWnd::DrawPolygon()
{
	if (m_bDrawingArea)
		return FALSE;
	m_bDrawingArea = TRUE;

	HObject polygon;
	try
	{
		HalconCpp::DrawPolygon(&polygon, m_hWindow);
	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("画多边形失败"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		return FALSE;
	}

	m_bDrawingArea = FALSE;
	return TRUE;
}

BOOL CHalconWnd::DrawRegion()
{
	if (m_bDrawingArea)
		return FALSE;
	m_bDrawingArea = TRUE;

	HObject region;
	try
	{
		HalconCpp::DrawRegion(&region, m_hWindow);
	}
	catch (HException & exception)
	{
		AfxMessageBox(_T("画区域失败"));
		if ((int)exception.ErrorCode() < 0)
			throw exception;
		return FALSE;
	}

	m_bDrawingArea = FALSE;
	return TRUE;
}

BOOL CHalconWnd::DrawArea(UINT nMode)
{
	switch(nMode)
	{
	case DRAW_RECTANGLE1:
		return this->DrawRectangle1();
	case DRAW_RECTANGLE2:
		return this->DrawRectangle2();
	case DRAW_CIRCLE:
		return this->DrawCircle();
	case DRAW_ELLIPSE:
		return this->DrawEllipse();
	case DRAW_POLYGON:
		return this->DrawPolygon();
	case DRAW_REGION:
		return this->DrawRegion();
	default:
		return FALSE;
	}
}

BOOL CHalconWnd::IsDrawingArea()
{
	return m_bDrawingArea;
}

BOOL CHalconWnd::ZoomIn()
{
	return this->Zoom(m_dbZoomFactor*1.10);
}
BOOL CHalconWnd::ZoomOut()
{
	return this->Zoom(m_dbZoomFactor*0.90);
}
double CHalconWnd::GetZoomFactor()
{
	return m_dbZoomFactor;
}
BOOL CHalconWnd::SetWindowHalcon(HTuple nPosX, HTuple nPosY, HTuple nWidth, HTuple nHeight)
{
	m_nZoomWidth = nWidth;
	m_nZoomHeight = nHeight;
	m_bZoom = TRUE;
	//设置halcon窗口大小
	//try
	//{
	//	HalconCpp::ClearWindow(m_hWindow);
	//	SetWindowExtents(m_hWindow, nPosX, nPosY, nWidth, nHeight);
	//	DispObj(m_hoImage, m_hWindow);
	//}
	//catch (HException & exception)
	//{
	//	AfxMessageBox(_T("相机窗口缩放失败"));
	//	if ((int)exception.ErrorCode() < 0)
	//		throw exception;
	//	return FALSE;
	//}
	return TRUE;
}

BOOL CHalconWnd::Zoom(double dbFactor)
{
	CRect rect;
	GetClientRect(&rect);

	//缩放率控制
	if (((double)rect.Width() / (double)rect.Height()) < (m_nImageWidth.D() / m_nImageHeight.D()))
	{
		if (dbFactor < ((double)rect.Width() / m_nImageWidth.D()))
			dbFactor = (double)rect.Width() / m_nImageWidth.D();
	}
	else
	{
		if (dbFactor < ((double)rect.Height() / m_nImageHeight.D()))
			dbFactor = (double)rect.Height() / m_nImageHeight.D();
	}
	//if(dbFactor < 0.1)
	//	dbFactor = 0.1;
	if(dbFactor > 1 )
		dbFactor = 1;

	m_dbZoomFactor = dbFactor;

	//获取窗口大小
	int nZoomWidth = (int)(dbFactor * (int)m_nImageWidth);
	int nZoomHeight = (int)(dbFactor * (int)m_nImageHeight);

	//设置halcon窗口大小
	SetWindowHalcon(0, 0, (HTuple)nZoomWidth, (HTuple)nZoomHeight);

	////设置滚动条范围
	SetDisplaySize(nZoomWidth, nZoomHeight);

	return TRUE;
}

void CHalconWnd::OnPaint()
{
	CPaintDC dc(this); // device context for painting
					   // TODO: 在此处添加消息处理程序代码
					   // 不为绘图消息调用 CWnd::OnPaint()

	//dc.SetWindowOrg(m_nLastHorzPos, m_nLastVertPos);
}


void CHalconWnd::AttachWnd(CWnd* pWnd)
{
	m_attachWnd = pWnd;
}

void CHalconWnd::DetachWnd()
{
	OnClose();

	//关闭相机
	if(NULL != m_pDevCam)
	{
		//无论相机关闭是否成功，都会删掉相机类
		if (!m_pDevCam->CloseDevCamera())
			AfxMessageBox(_T("关闭相机失败"));
		delete m_pDevCam;
		m_pDevCam = NULL;
	}

	m_attachWnd = NULL;
}

void CHalconWnd::SetDisplaySize(int displayWidth, int displayHeight)
{
	m_displaySize = CSize(displayWidth, displayHeight);

	if (m_attachWnd != NULL && ::IsWindow(m_attachWnd->m_hWnd))
		UpdateScrollInfo();
}

const CSize& CHalconWnd::GetDisplaySize() const
{
	return m_displaySize;
}

const CSize& CHalconWnd::GetScrollPos() const
{
	return m_scrollPos;
}

const CSize& CHalconWnd::GetPageSize() const
{
	return m_pageSize;
}

void CHalconWnd::ScrollToOrigin(bool scrollLeft, bool scrollTop)
{
	if (m_attachWnd == NULL)
		return;

	if (scrollLeft)
	{
		if (m_displaySize.cx > 0 && m_pageSize.cx > 0 && m_scrollPos.cx > 0)
		{
			int deltaPos = -m_scrollPos.cx;
			m_scrollPos.cx += deltaPos;
			m_attachWnd->SetScrollPos(SB_HORZ, m_scrollPos.cx, TRUE);
			m_attachWnd->ScrollWindow(-deltaPos, 0);
		}
	}

	if (scrollTop)
	{
		if (m_displaySize.cy > 0 && m_pageSize.cy > 0 && m_scrollPos.cy > 0)
		{
			int deltaPos = -m_scrollPos.cy;
			m_scrollPos.cy += deltaPos;
			m_attachWnd->SetScrollPos(SB_VERT, m_scrollPos.cy, TRUE);
			m_attachWnd->ScrollWindow(0, -deltaPos);
		}
	}
}

void CHalconWnd::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	if (m_attachWnd == NULL)
		return;

	const int lineOffset = 60;

	// Compute the desired change or delta in scroll position.
	int deltaPos = 0;
	switch (nSBCode)
	{
	case SB_LINELEFT:
		// Left scroll arrow was pressed.
		deltaPos = -lineOffset;
		break;

	case SB_LINERIGHT:
		// Right scroll arrow was pressed.
		deltaPos = lineOffset;
		break;

	case SB_PAGELEFT:
		// User clicked inbetween left arrow and thumb.
		deltaPos = -m_pageSize.cx;
		break;

	case SB_PAGERIGHT:
		// User clicked inbetween thumb and right arrow.
		deltaPos = m_pageSize.cx;
		break;

	case SB_THUMBTRACK:
		// Scrollbar thumb is being dragged.
		deltaPos = Get32BitScrollPos(SB_HORZ, pScrollBar) - m_scrollPos.cx;
		break;

	case SB_THUMBPOSITION:
		// Scrollbar thumb was released.
		deltaPos = Get32BitScrollPos(SB_HORZ, pScrollBar) - m_scrollPos.cx;
		break;

	default:
		// We don't process other scrollbar messages.
		return;
	}

	// Compute the new scroll position.
	int newScrollPos = m_scrollPos.cx + deltaPos;

	// If the new scroll position is negative, we adjust
	// deltaPos in order to scroll the window back to origin.
	if (newScrollPos < 0)
		deltaPos = -m_scrollPos.cx;

	// If the new scroll position is greater than the max scroll position,
	// we adjust deltaPos in order to scroll the window precisely to the
	// maximum position.
	int maxScrollPos = m_displaySize.cx - m_pageSize.cx;
	if (newScrollPos > maxScrollPos)
		deltaPos = maxScrollPos - m_scrollPos.cx;

	// Scroll the window if needed.
	if (deltaPos != 0)
	{
		m_scrollPos.cx += deltaPos;
		m_attachWnd->SetScrollPos(SB_HORZ, m_scrollPos.cx, TRUE);
		m_attachWnd->ScrollWindow(-deltaPos, 0);
	}
}


void CHalconWnd::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	if (m_attachWnd == NULL)
		return;

	const int lineOffset = 60;

	// Compute the desired change or delta in scroll position.
	int deltaPos = 0;
	switch (nSBCode)
	{
	case SB_LINEUP:
		// Up arrow button on scrollbar was pressed.
		deltaPos = -lineOffset;
		break;

	case SB_LINEDOWN:
		// Down arrow button on scrollbar was pressed.
		deltaPos = lineOffset;
		break;

	case SB_PAGEUP:
		// User clicked inbetween up arrow and thumb.
		deltaPos = -m_pageSize.cy;
		break;

	case SB_PAGEDOWN:
		// User clicked inbetween thumb and down arrow.
		deltaPos = m_pageSize.cy;
		break;

	case SB_THUMBTRACK:
		// Scrollbar thumb is being dragged.
		deltaPos = Get32BitScrollPos(SB_VERT, pScrollBar) - m_scrollPos.cy;
		break;

	case SB_THUMBPOSITION:
		// Scrollbar thumb was released.
		deltaPos = Get32BitScrollPos(SB_VERT, pScrollBar) - m_scrollPos.cy;
		break;

	default:
		// We don't process other scrollbar messages.
		return;
	}

	// Compute the new scroll position.
	int newScrollPos = m_scrollPos.cy + deltaPos;

	// If the new scroll position is negative, we adjust
	// deltaPos in order to scroll the window back to origin.
	if (newScrollPos < 0)
		deltaPos = -m_scrollPos.cy;

	// If the new scroll position is greater than the max scroll position,
	// we adjust deltaPos in order to scroll the window precisely to the
	// maximum position.
	int maxScrollPos = m_displaySize.cy - m_pageSize.cy;
	if (newScrollPos > maxScrollPos)
		deltaPos = maxScrollPos - m_scrollPos.cy;

	// Scroll the window if needed.
	if (deltaPos != 0)
	{
		m_scrollPos.cy += deltaPos;
		m_attachWnd->SetScrollPos(SB_VERT, m_scrollPos.cy, TRUE);
		m_attachWnd->ScrollWindow(0, -deltaPos);
	}
}

void CHalconWnd::OnSize(UINT nType, int cx, int cy)
{
	UpdateScrollInfo();
}


int CHalconWnd::Get32BitScrollPos(int bar, CScrollBar* pScrollBar)
{
	// Code below is from MSDN Article ID 152252, "How To Get
	// 32-bit Scroll Position During Scroll Messages".

	// First determine if the user scrolled a scroll bar control
	// on the window or scrolled the window itself.
	ASSERT(m_attachWnd != NULL);
	HWND hWndScroll;
	if (pScrollBar == NULL)
		hWndScroll = m_attachWnd->m_hWnd;
	else
		hWndScroll = pScrollBar->m_hWnd;

	SCROLLINFO si;
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_TRACKPOS;
	::GetScrollInfo(hWndScroll, bar, &si);

	int scrollPos = si.nTrackPos;

	return scrollPos;
}

void CHalconWnd::UpdateScrollInfo()
{
	if (m_attachWnd == NULL)
		return;

	// Get the width/height of the attached wnd that includes the area
	// covered by the scrollbars (if any). The reason we need this is
	// because when scrollbars are present, both cx/cy and GetClientRect()
	// when accessed from OnSize() do not include the scrollbar covered
	// areas. In other words, their values are smaller than what you would
	// expect.
	CRect rect;
	GetClientRectSB(m_attachWnd, rect);
	CSize windowSize(rect.Width(), rect.Height());

	// Update horizontal scrollbar.
	CSize deltaPos(0, 0);
	UpdateScrollBar(SB_HORZ, windowSize.cx, m_displaySize.cx,
		m_pageSize.cx, m_scrollPos.cx, deltaPos.cx);

	// Update vertical scrollbar.
	UpdateScrollBar(SB_VERT, windowSize.cy, m_displaySize.cy,
		m_pageSize.cy, m_scrollPos.cy, deltaPos.cy);

	// See if we need to scroll the window back in place.
	// This is needed to handle the case where the scrollbar is
	// moved all the way to the right for example, and controls
	// at the left side disappear from the view. Then the user
	// resizes the window wider until scrollbars disappear. Without
	// this code below, the controls off the page will be gone forever.
	if (deltaPos.cx != 0 || deltaPos.cy != 0)
	{
		m_attachWnd->ScrollWindow(deltaPos.cx, deltaPos.cy);
	}
}

void CHalconWnd::UpdateScrollBar(int bar, int windowSize, int displaySize,
	LONG& pageSize, LONG& scrollPos, LONG& deltaPos)
{
	int scrollMax = 0;
	deltaPos = 0;
	if (windowSize < displaySize)
	{
		scrollMax = displaySize - 1;
		if (pageSize > 0 && scrollPos > 0)
		{
			// Adjust the scroll position when the window size is changed.
			scrollPos = (LONG)(1.0 * scrollPos * windowSize / pageSize);
		}
		pageSize = windowSize;
		scrollPos = min(scrollPos, displaySize - pageSize - 1);
		deltaPos = m_attachWnd->GetScrollPos(bar) - scrollPos;
	}
	else
	{
		// Force the scrollbar to go away.
		pageSize = 0;
		scrollPos = 0;
		deltaPos = m_attachWnd->GetScrollPos(bar);
	}

	SCROLLINFO si;
	memset(&si, 0, sizeof(SCROLLINFO));
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_ALL;    // SIF_ALL = SIF_PAGE | SIF_RANGE | SIF_POS;
	si.nMin = 0;
	si.nMax = scrollMax;
	si.nPage = pageSize;
	si.nPos = scrollPos;
	m_attachWnd->SetScrollInfo(bar, &si, TRUE);
}


BOOL CHalconWnd::OnEraseBkgnd(CDC* pDC)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值
	return TRUE;
	//return CWnd::OnEraseBkgnd(pDC);
}

void CHalconWnd::OnOpenCamera()
{
	if (!m_bThreadsAreRunning)
	{
		StartThreads();
		m_bThreadsAreRunning = TRUE;
	}
}

void CHalconWnd::OnCloseCamera()
{
	if (m_bThreadsAreRunning)
	{
		ClearContourMask();
		ClearStringMask();
		SetEvent(fgStopEvent);
		m_bThreadsAreRunning = FALSE;
		g_ptDxfTranslate = CPointF();
		g_fDxfRotate = 0;
	}
}

// ======================================================================== 
// ======================================================================== 	
// StartThreading() - Once the start button is pressed, the function
//                    StartThreads() is called. This function resets/sets
//					          all necessary event handles and initiates the (global) 
//					          thread functions by calling _beginthreadex(ThreadHandle,
//                                                               ........)
//
void CHalconWnd::StartThreads()
{

	// reset all event handles to initial states 
	ResetEvent(fgStopEvent);
	ResetEvent(newImageEvent);
	ResetEvent(newResultEvent);
	SetEvent(containerIsFreeEvent);

	//imgList.clear();
	imgList.RemoveAll();

	// stop threads if still running ...
	if ((*this).m_pThImgProc)
	{
		WaitForSingleObject(m_pThImgProc->m_hThread, INFINITE);
		//CloseHandle((*this).m_pThImgProc->m_hThread);
		StopThread(m_pThImgProc);
	}
	if ((*this).m_pThImgAcq)
	{
		WaitForSingleObject(m_pThImgAcq->m_hThread, INFINITE);
		//CloseHandle((*this).m_pThImgAcq->m_hThread);
		StopThread(m_pThImgAcq);
	}

	// start threads 
	//ipThrHandle = (HANDLE)_beginthreadex(NULL,
	//	0,
	//	(unsigned(__stdcall*)(void*)) & IPRun,
	//	this,
	//	0,
	//	&ipThreadId);

	//fgThrHandle = (HANDLE)_beginthreadex(NULL,
	//	0,
	//	(unsigned(__stdcall*)(void*)) & ImgAcqRun,
	//	this,
	//	0,
	//	&fgThreadId);

	m_pThImgProc = AfxBeginThread(ImgProcRun, this, THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED, 0);
	m_pThImgProc->m_bAutoDelete = FALSE;
	m_pThImgProc->ResumeThread();

	m_pThImgAcq = AfxBeginThread(ImgAcqRun, this, THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED, 0);
	m_pThImgAcq->m_bAutoDelete = FALSE;
	m_pThImgAcq->ResumeThread();

}

void CHalconWnd::StopThread(CWinThread* pThred)
{
	//停止采集
	DWORD dwExit = 0;
	MSG msg;
	do
	{
		Sleep(1);
		GetExitCodeThread(pThred->m_hThread, &dwExit);
		if (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			::TranslateMessage(&msg);
			::DispatchMessage(&msg);
		}
	} while (dwExit == STILL_ACTIVE);

	//删除线程指针
	delete pThred;
}

// ======================================================================== 
// ======================================================================== 
// ImgProcRun(void*) - This thread function performs the image processing task.                  
//                As input, the thread needs a pointer to the 
//                MultiThreadingDlg instance that initialized and started
//                the thread.
//

UINT CHalconWnd::ImgProcRun(LPVOID lpParam)
{
	//ResultContainer赋值
	//HTuple      T1, resultHandles, decodedDataStrings, T2;
	//HObject     symbolXLDs;
	//CString     sVal;
	//HTuple      dataCodeHandle;
	struct ResultContainer ResultDataIP;
	////创造模板函数传参
	//HTuple	hvModelID;
	//HObject	imgROI, imgModelImage, rgnModelRegion;
	////匹配模板函数传参
	//HTuple hvModelIDMatch, hvContoursAffineTransRow, hvContoursAffineTransColumn, hvContoursAffineTransAngle;
	//HObject xldModelContour, xldContoursAffineTrans;
	//手动定位圆函数传参
	HObject	xldContourCircleHand;
	HTuple	hvParameterCircleHand;
	//自动定位多个圆函数传参
	HObject	xldContourCircles;
	HTuple	hvParameterCircles;



	HObject      image;
	HANDLE      eventHandle[2];

	CHalconWnd* pHalconWnd = (CHalconWnd*)lpParam;
	const HWND hPostWnd = pHalconWnd->GetSafeHwnd();

	// --------------------  INIT -------------------------------------- 
	//CreateDataCode2dModel("Data Matrix ECC 200", HTuple(), HTuple(),
	//	&dataCodeHandle);
	//SetDataCode2dParam(dataCodeHandle, "default_parameters",
	//	"enhanced_recognition");


	// -----------------  WAIT FOR EVENTS  ----------------------------- 
	eventHandle[0] = (*pHalconWnd).newImageEvent;
	eventHandle[1] = (*pHalconWnd).fgStopEvent;

	int nCt = 0;
	while (WAIT_OBJECT_0 == WaitForMultipleObjects(2, eventHandle,
		FALSE, INFINITE))
	{
		TRACE("ImgProcRun_Count = %d \n", ++nCt);

		EnterCriticalSection(&pHalconWnd->newImageMutex);        // CriticalSect
		//image = (pHalconWnd->imgList).front();					 // CriticalSect
		//pHalconWnd->imgList.pop_front();						 // CriticalSect
		image = pHalconWnd->imgList.GetHead();
		pHalconWnd->imgList.RemoveHead();
		LeaveCriticalSection(&pHalconWnd->newImageMutex);        // CriticalSect

		//图像预处理函数
		if (TRUE == g_bCameraSettingChanged)
		{
			pHalconWnd->m_nImgReverse = ReadDevCameraReverse();
			pHalconWnd->m_nImgBrightness = ReadDevCameraBrightness();
			pHalconWnd->m_nImgContrast = ReadDevCameraContrast();
			g_bCameraSettingChanged = FALSE;
		}
		if (pHalconWnd->m_nImgReverse)
			pHalconWnd->ReverseImgColor(image, &image);
		pHalconWnd->SetImgBrightness(image, &image, pHalconWnd->m_nImgBrightness);
		pHalconWnd->SetImgContrast(image, &image, pHalconWnd->m_nImgContrast);


		//图像处理函数
		//if (pHalconWnd->m_bTestCreateModel)
		//{
		//	//pHalconWnd->ThreadFuncTestCreateModel(image);
		//	pHalconWnd->ThreadFuncTestCreateModel(image, &imgROI, &hvModelID, &imgModelImage, &rgnModelRegion);
		//}
		//if (pHalconWnd->m_bTestMatchModel)
		//{
		//	//pHalconWnd->ThreadFuncTestMatchModel(image, &symbolXLDs);
		//	pHalconWnd->ThreadFuncTestMatchModel(image, &hvModelIDMatch, &xldModelContour, &xldContoursAffineTrans,
		//		&hvContoursAffineTransRow, &hvContoursAffineTransColumn, &hvContoursAffineTransAngle);
		//}
		if (pHalconWnd->m_bTestFindCircleHand)
		{
			pHalconWnd->ThreadFuncTestFindCircleHand(image, &xldContourCircleHand, &hvParameterCircleHand);
		}

		if (pHalconWnd->m_bTestFindCircles)
		{
			pHalconWnd->ThreadFuncTestFindCircles(image, &xldContourCircles, &hvParameterCircles);
		}


		//CountSeconds(&T1);
		//FindDataCode2d(image, &symbolXLDs, dataCodeHandle,
		//	HTuple(), HTuple(), &resultHandles, &decodedDataStrings);
		//CountSeconds(&T2);

		//赋值ResultContainer赋值
		//ResultDataIP.time_needed = 1000 * (T2[0].D() - T1[0].D());
		//ResultDataIP.find_data = decodedDataStrings;
		//ResultDataIP.result_img = image;
		//ResultDataIP.result_handle = resultHandles;
		//ResultDataIP.symbol_data = symbolXLDs;
		ResultDataIP.imgCameraImage = image;
		//ResultDataIP.imgROI = imgROI;
		//ResultDataIP.hvModelID = hvModelID;
		//ResultDataIP.imgModelImage = imgModelImage;
		//ResultDataIP.rgnModelRegion = rgnModelRegion;

		//ResultDataIP.hvModelIDMatch = hvModelIDMatch;
		//ResultDataIP.xldModelContour = xldModelContour;
		//ResultDataIP.xldContoursAffineTrans = xldContoursAffineTrans;
		//ResultDataIP.hvContoursAffineTransRow = hvContoursAffineTransRow;
		//ResultDataIP.hvContoursAffineTransColumn = hvContoursAffineTransColumn;
		//ResultDataIP.hvContoursAffineTransAngle = hvContoursAffineTransAngle;

		ResultDataIP.xldContourCircleHand = xldContourCircleHand;
		ResultDataIP.hvParameterCircleHand = hvParameterCircleHand;

		ResultDataIP.xldContourCircles = xldContourCircles;
		ResultDataIP.hvParameterCircles = hvParameterCircles;

		EnterCriticalSection(&pHalconWnd->resultDataMutex);      // CriticalSect
		pHalconWnd->resultData = ResultDataIP;                   // CriticalSect
		::PostMessage(hPostWnd,   // handle to view window
			WM_DISP,   // message to post
			(WPARAM)NULL,  // window message parameter
			(LPARAM)NULL);
		LeaveCriticalSection(&pHalconWnd->resultDataMutex);      // CriticalSect
	}

	return 0;
}

// ======================================================================== 
// ======================================================================== 
//  ImgAcqRun()    - The thread function implements the grabbing task.               
//                   As input, the thread needs a pointer to the 
//                   MultiThreadingDlg instance that initialized and 
//                   started the thread.
//
UINT CHalconWnd::ImgAcqRun(LPVOID lpParam)
{
	HObject ho_grabbedImage;
	CHalconWnd* pHalconWnd = (CHalconWnd*)lpParam;
	
	// ---------------------  INIT  ------------------------------------ 
	////相机硬件初始化
	//if (NULL != pHalconWnd->m_pDevCam)
	//{
	//	delete pHalconWnd->m_pDevCam;
	//	pHalconWnd->m_pDevCam = NULL;
	//}

	////读ini并动态生成相机硬件类
	//switch (ReadDevCameraName())
	//{
	//case CAMERA_NAME::CAMERA_NONE:
	//	pHalconWnd->m_pDevCam = NULL;
	//	break;
	//case CAMERA_NAME::CAMERA_GENERAL_GE:
	//	pHalconWnd->m_pDevCam = new CDeviceCameraGeneralGE;
	//	break;
	//case CAMERA_NAME::CAMERA_DAHENG_MER:
	//	pHalconWnd->m_pDevCam = new CDeviceCameraDahengMER;
	//	break;
	//case CAMERA_NAME::CAMERA_2:
	//	pHalconWnd->m_pDevCam = NULL;
	//	break;
	//default:
	//	pHalconWnd->m_pDevCam = NULL;
	//	break;
	//}

	////如果选择的相机不存在，则停止进程
	//if (NULL == pHalconWnd->m_pDevCam)							
	//{
	//	AfxMessageBox(_T("未找到所选相机，请在设备配置里选择相机型号"));
	//	SetEvent(pHalconWnd->fgStopEvent);
	//	pHalconWnd->m_bThreadsAreRunning = FALSE;
	//	return 1;
	//}

	////如果相机类已成功生成，则打开相机
	////如果相机打开失败，则停止进程
	//if (FALSE == pHalconWnd->m_pDevCam->OpenDevCamera())	
	//{
	//	//delete pHalconWnd->m_pDevCam;
	//	//pHalconWnd->m_pDevCam = NULL;
	//	AfxMessageBox(_T("相机打开失败"));
	//	SetEvent(pHalconWnd->fgStopEvent);
	//	pHalconWnd->m_bThreadsAreRunning = FALSE;
	//	return 1;
	//}

	//如果相机已打开，则开始采集
	//如果采集失败，则停止进程
	if (NULL == pHalconWnd->m_pDevCam || FALSE == pHalconWnd->m_pDevCam->StartAcqImg())
	{
		AfxMessageBox(_T("开始采集失败"));
		SetEvent(pHalconWnd->fgStopEvent);
		pHalconWnd->m_bThreadsAreRunning = FALSE;
		return 1;
	}

	int nCt = 0;
	// -----------------  WAIT FOR EVENTS  ----------------------------- 
	while (WAIT_OBJECT_0 != WaitForSingleObject((pHalconWnd->fgStopEvent), 0))
	{
		TRACE("ImgAcqRun_Count = %d \n", ++nCt);

		if (TRUE == g_bCameraSettingChanged)
		{
			//设置采集图像参数
			pHalconWnd->m_nImgReverse = ReadDevCameraReverse();
			pHalconWnd->m_nImgBrightness = ReadDevCameraBrightness();
			pHalconWnd->m_nImgContrast = ReadDevCameraContrast();

			int nImgMirrorXTmp, nImgMirrorYTmp, nImgExposureTmp, nImgGainTmp;
			nImgMirrorXTmp = ReadDevCameraMirrorX();
			nImgMirrorYTmp = ReadDevCameraMirrorY();
			nImgExposureTmp = ReadDevCameraExposure();
			nImgGainTmp = ReadDevCameraGain();		
			if (nImgMirrorXTmp != pHalconWnd->m_nImgMirrorX)
			{
				pHalconWnd->m_pDevCam->SetImgMirrorX(nImgMirrorXTmp);
				pHalconWnd->m_nImgMirrorX = nImgMirrorXTmp;
			}
			if (nImgMirrorYTmp != pHalconWnd->m_nImgMirrorY)
			{
				pHalconWnd->m_pDevCam->SetImgMirrorY(nImgMirrorYTmp);
				pHalconWnd->m_nImgMirrorY = nImgMirrorYTmp;
			}
			if (nImgExposureTmp != pHalconWnd->m_nImgExposure)
			{
				pHalconWnd->m_pDevCam->SetImgExposure(nImgExposureTmp);
				pHalconWnd->m_nImgExposure = nImgExposureTmp;
			}
			if (nImgGainTmp != pHalconWnd->m_nImgGain)
			{
				pHalconWnd->m_pDevCam->SetImgGain(nImgGainTmp);
				pHalconWnd->m_nImgGain = nImgGainTmp;
			}
			g_bCameraSettingChanged = FALSE;
		}
			   
		//软触发读图
		ho_grabbedImage = pHalconWnd->m_pDevCam->GrabImgBySoftCommand();	
		//CopyImage(pHalconWnd->m_pDevCam->GrabImgBySoftCommand(), &ho_grabbedImage); 
		if (!ho_grabbedImage.IsInitialized())
		{
			AfxMessageBox(_T("软触发采集失败"));
			SetEvent(pHalconWnd->fgStopEvent);
			pHalconWnd->m_bThreadsAreRunning = FALSE;
		}

		////图像预处理函数
		//int nImgReverseTmp, nImgBrightnessTmp, nImgContrastTmp;
		//nImgReverseTmp = ReadDevCameraReverse();
		//nImgBrightnessTmp = ReadDevCameraBrightness();
		//nImgContrastTmp = ReadDevCameraContrast();
		//if (nImgReverseTmp != pHalconWnd->m_nImgReverse)
		//{
		//	pHalconWnd->ReverseImgColor(ho_grabbedImage, &ho_grabbedImage);
		//}
		//if (nImgBrightnessTmp != pHalconWnd->m_nImgBrightness)
		//{
		//	pHalconWnd->SetImgBrightness(ho_grabbedImage, &ho_grabbedImage, nImgBrightnessTmp);
		//}
		//if (nImgContrastTmp != pHalconWnd->m_nImgContrast)
		//{
		//	pHalconWnd->SetImgContrast(ho_grabbedImage, &ho_grabbedImage, nImgContrastTmp);
		//}

		EnterCriticalSection(&pHalconWnd->newImageMutex);        // CriticalSect
		//标定
		MapImage(ho_grabbedImage, ho_Map, &ho_grabbedImage);

		if (pHalconWnd->imgList.GetSize() < MAX_BUFFERS)
		{
			pHalconWnd->imgList.AddTail(ho_grabbedImage);
		}
		else
		{
			pHalconWnd->imgList.RemoveTail();
			pHalconWnd->imgList.AddTail(ho_grabbedImage);
		}
		LeaveCriticalSection(&pHalconWnd->newImageMutex);        // CriticalSect

		SetEvent(pHalconWnd->newImageEvent);
	}

	// -----------------  RESET/CLOSE ALL HANDLES  --------------------- 
	ResetEvent(pHalconWnd->newImageEvent);

	//停止采集
	//CloseFramegrabber(hv_AcqHandle);
	if (!pHalconWnd->m_pDevCam->StopAcqImg())
	{
		AfxMessageBox(_T("停止采集失败"));
	}

	////关闭相机
	//if(NULL != pHalconWnd->m_pDevCam)
	//{
	//	//无论相机关闭是否成功，都会删掉相机类
	//	if (!pHalconWnd->m_pDevCam->CloseDevCamera())
	//		AfxMessageBox(_T("关闭相机失败"));
	//	//delete pHalconWnd->m_pDevCam;
	//	//pHalconWnd->m_pDevCam = NULL;
	//}

	return 0;
}


void CHalconWnd::OnClose()
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值
	if (m_bThreadsAreRunning)
	{
		SetEvent(fgStopEvent);
		m_bThreadsAreRunning = FALSE;

		//WaitForSingleObject(m_pThImgProc->m_hThread, INFINITE);
		//WaitForSingleObject(m_pThImgAcq->m_hThread, INFINITE);
	}


	//if ((*this).ipThrHandle)
	//	CloseHandle((*this).ipThrHandle);
	//if ((*this).fgThrHandle)
	//	CloseHandle((*this).fgThrHandle);
	if ((*this).m_pThImgProc)
	{
		WaitForSingleObject(m_pThImgProc->m_hThread, INFINITE);
		//CloseHandle((*this).m_pThImgProc->m_hThread);
		StopThread(m_pThImgProc);
	}
	if ((*this).m_pThImgAcq)
	{
		WaitForSingleObject(m_pThImgAcq->m_hThread, INFINITE);
		//CloseHandle((*this).m_pThImgAcq->m_hThread);
		StopThread(m_pThImgAcq);
	}
	
	CloseHandle(this->fgStopEvent);
	CloseHandle(this->newImageEvent);
	CloseHandle(this->newResultEvent);
	CloseHandle(this->containerIsFreeEvent);
	CloseHandle(this->hdFindDone);

	DeleteCriticalSection(&newImageMutex);
	DeleteCriticalSection(&resultDataMutex);

	CWnd::OnClose();
}


LRESULT CHalconWnd::OnDisp(WPARAM wParam, LPARAM lParam)
{
	// ======================================================================== 
// ======================================================================== 	
// OnDisp() - The OnDisp method also allows derived classes to handle the 
//             event without attaching a delegate. This is the preferred 
//			       technique for handling the event in a derived class.
//

	struct ResultContainer ResultDataDisp;

	if (FALSE == m_bThreadsAreRunning)
		return 0L;

	// -----------------  DISPLAY RESULTS  ----------------------------- 

	EnterCriticalSection(&resultDataMutex);      // CriticalSect
	ResultDataDisp = resultData;                          // CriticalSect
	CopyImage(ResultDataDisp.imgCameraImage, &m_hoImageDisplay);
	LeaveCriticalSection(&resultDataMutex);      // CriticalSect

	//ResultContainer赋值
	//HTuple   time = rData.time_needed;
	//HTuple   decodedDataStrings = rData.find_data;
	//HImage   image = rData.result_img;
	//HTuple   resultHandles = rData.result_handle;
	//HXLDCont symbolXLDs = rData.symbol_data;
	HImage   imgCameraImage = ResultDataDisp.imgCameraImage;
	//HImage   imgROI = ResultDataDisp.imgROI;
	//HTuple	hvModelID = ResultDataDisp.hvModelID;
	//HImage	imgModelImage = ResultDataDisp.imgModelImage;
	//HRegion	rgnModelRegion = ResultDataDisp.rgnModelRegion;
	//HXLD	xldModelContour = ResultDataDisp.xldModelContour;
	//HXLD	xldContoursAffineTrans = ResultDataDisp.xldContoursAffineTrans;
	//HTuple	hvContoursAffineTransRow = ResultDataDisp.hvContoursAffineTransRow;
	//HTuple	hvContoursAffineTransColumn = ResultDataDisp.hvContoursAffineTransColumn;
	//HTuple	hvContoursAffineTransAngle = ResultDataDisp.hvContoursAffineTransAngle;
	HXLD xldContourCircleHand = ResultDataDisp.xldContourCircleHand;
	HTuple hvParameterCircleHand = ResultDataDisp.hvParameterCircleHand;
	HXLD xldContourCircles = ResultDataDisp.xldContourCircles;
	HTuple hvParameterCircles = ResultDataDisp.hvParameterCircles;


	if (m_bZoom)
	{
		SetWindowExtents(m_hWindow, 0, 0, m_nZoomWidth, m_nZoomHeight);
		m_bZoom = FALSE;
	}
	
	//开始绘制画布/////////////////////////////////////////////////////////////////////////////////////////
	HalconCpp::SetSystem("flush_graphic", "false");

	//显示原图
	//DispObj(image, m_hWindow);
	//HObject hoReadImg;
	//ReadImage(&hoReadImg, "D://YuanLu//4. Halcon//CCD Sample//2021-03-10_10_39_07_5512.bmp");
	//DispObj(hoReadImg, m_hWindow);
	DispObj(imgCameraImage, m_hWindow);
	SetColor(m_hWindow, "red");
	DispObj(m_hoContourMask, m_hWindow);
	ShowStringMask();
	//if(m_bShowString)
	//	DispText(m_hWindow, m_hvString, "image", m_hvStringRow + 3, m_hvStringColumn + 3, "black", HTuple(), HTuple());
	SetColor(m_hWindow, "green");

	//显示十字靶标
	DispLine(m_hWindow, m_nImageHeight / 2, 0, m_nImageHeight / 2, m_nImageWidth);
	DispLine(m_hWindow, 0, m_nImageWidth / 2, m_nImageHeight, m_nImageWidth / 2);
	DispArc(m_hWindow, m_nImageHeight / 2, m_nImageWidth / 2, HTuple(360).TupleRad(), m_nImageHeight / 2, 200 + m_nImageWidth / 2);

	//显示框选的区域
	//if (m_bTestCreateModel)
	//{
	//	if(m_hoImageROI.IsInitialized())
	//		DispObj(m_hoImageROI, m_hWindow);
	//}
	//HTuple area, row, col;
	//if (imgROI.IsInitialized())
	//{
	//	AreaCenter(imgROI, &area, &row, &col);
	//	SetTposition(m_hWindow, 74, 212);
	//	WriteString(m_hWindow, "area: " + area);
	//	SetTposition(m_hWindow, 124, 212);
	//	WriteString(m_hWindow, "Row: " + row);
	//	SetTposition(m_hWindow, 174, 212);
	//	WriteString(m_hWindow, "Col: " + col);
	//}

	////显示处理得到的轮廓
	////if (m_bTestMatchModel)
	//	//DispObj(symbolXLDs, m_hWindow);
	//if (xldContoursAffineTrans.IsInitialized())
	//{
	//	DispObj(xldContoursAffineTrans, m_hWindow);
	//	SetTposition(m_hWindow, 74, 512);
	//	WriteString(m_hWindow, "hvContoursAffineTransRow: " + hvContoursAffineTransRow);
	//	SetTposition(m_hWindow, 124, 512);
	//	WriteString(m_hWindow, "hvContoursAffineTransColumn: " + hvContoursAffineTransColumn);
	//	SetTposition(m_hWindow, 174, 512);
	//	WriteString(m_hWindow, "hvContoursAffineTransAngle: " + hvContoursAffineTransAngle);
	//}

	
	DispTestFindCircleHand(xldContourCircleHand, hvParameterCircleHand);
	DispTestFindCircles(xldContourCircles, hvParameterCircles);


	//显示处理时间
	//CString sVal;
	//sVal.Format(_T("%4.2f"), time[0].D());
	//ipProcTime.SetWindowText(sVal + " ms");
	//for (Hlong i = 0; i <= (resultHandles.Length()) - 1; i += 1)
	//{
	//	ipImgLabel.SetWindowText(decodedDataStrings[i].S().TextW());
	//}

	HalconCpp::SetSystem("flush_graphic", "true");
	//结束绘制画布，并刷新画布/////////////////////////////////////////////////////////////////////////////////////////

	return 0L;

}


//void CHalconWnd::TestCreateModel()
//{
//	DrawRectangle1();
//	m_bTestCreateModel = TRUE;
//}
//void CHalconWnd::ThreadFuncTestCreateModel(HObject imgCameraImage, HObject* imgROI, HTuple* hvModelID, HObject* imgModelImage, HObject* rgnModelRegion)
//{
//	HObject hoRectangle, hoImageReduced, hoCameraRegionThreshold, hoCameraRegionConnection, hoRegionSelected, hoCameraRegionUnion, hoCameraRegionFillUp, hoCameraRegionROI;
//	HTuple  hv_Contrast, hv_HysteresisContrast;
//	hv_Contrast = 20;
//	hv_HysteresisContrast.Clear();
//	hv_HysteresisContrast.Append(hv_Contrast / 2);
//	hv_HysteresisContrast.Append(hv_Contrast + 6);
//	hv_HysteresisContrast.Append(10);
//
//	try
//	{
//		GenRectangle1(&hoRectangle, drawRectRow1, drawRectColumn1, drawRectRow2, drawRectColumn2);
//		ReduceDomain(imgCameraImage, hoRectangle, &hoImageReduced);
//		//Rgb1ToGray(imgCameraImage, &hoCameraImageGray);
//		Threshold(hoImageReduced, &hoCameraRegionThreshold, 120, 255);
//		Connection(hoCameraRegionThreshold, &hoCameraRegionConnection);
//		SelectShape(hoCameraRegionConnection, &hoRegionSelected, ("area", "circularity"), "and", (150, 0.8), (6000000, 1));
//		Union1(hoRegionSelected, &hoCameraRegionUnion);
//		FillUp(hoCameraRegionUnion, &hoCameraRegionFillUp);
//		DilationCircle(hoCameraRegionFillUp, &hoCameraRegionROI, 1.5);
//		ReduceDomain(imgCameraImage, hoCameraRegionROI, &(*imgROI));
//
//		ReduceDomain(imgCameraImage, hoCameraRegionROI, &hoImageReduced);
//
//		CreateShapeModel((*imgROI), "auto", 0, HTuple(360).TupleRad(), "auto", "none",
//			"ignore_local_polarity", hv_HysteresisContrast, 5, &(*hvModelID));
//		//CreateShapeModel((*imgROI), "auto", 0, HTuple(360).TupleRad(), "auto", "none",
//		//	"ignore_local_polarity", "auto", "auto", &(*hvModelID));
//		InspectShapeModel((*imgROI), &(*imgModelImage), &(*rgnModelRegion), 1, 30);
//
//		WriteShapeModel((*hvModelID), _T("./fff_hvModelID.shm"));
//		WriteRegion(hoCameraRegionROI, _T("./fff_hoCameraRegionROI.tiff"));
//		WriteImage(hoImageReduced, "bmp", 0, _T("./fff_hoImageReduced.bmp"));
//		//WriteImage((*rgnModelRegion), "bmp", 0, "C://Users//Jason Zou//Desktop//CCD Sample//fff_(*rgnModelRegion).bmp");
//
//	}
//	catch (HException & exception)
//	{
//		AfxMessageBox(exception.ErrorMessage());
//		if ((int)exception.ErrorCode() < 0)
//			throw exception;
//	}
//	m_bTestCreateModel = FALSE;
//}
//
//void CHalconWnd::TestMatchModel()
//{
//	//HTuple ShapeModelOrgRow, ShapeModelOrgCol;
//	//HTuple NumLevels, AngleStart, AngleExtent, AngleStep, ScaleMin, ScaleMax, ScaleStep, Metric, MinContrast;
//
//	//try
//	//{
//	//	ReadShapeModel("C://Users//Jason Zou//Desktop//CCD Sample//zzz_ShapeModel.shm", &m_hoShapeModelID);
//	//	GetShapeModelContours(&m_hoShapeModelContour, m_hoShapeModelID, 1);
//	//	GetShapeModelOrigin(m_hoShapeModelID, &ShapeModelOrgRow, &ShapeModelOrgCol);
//	//	GetShapeModelParams(m_hoShapeModelID, &NumLevels, 
//	//		&AngleStart, &AngleExtent, &AngleStep,
//	//		&ScaleMin, &ScaleMax, &ScaleStep,
//	//		&Metric, &MinContrast);
//
//	//	ReadImage(&m_hoShapeModelImage, "C://Users//Jason Zou//Desktop//CCD Sample//zzz_ImageROI.bmp");
//	//	GetDomain(m_hoShapeModelImage, &m_hoDomainModelRegion);
//	//}
//	//catch (HException & exception)
//	//{
//	//	AfxMessageBox(exception.ErrorMessage());
//	//	if ((int)exception.ErrorCode() < 0)
//	//		throw exception;
//	//}
//
//	m_bTestMatchModel = TRUE;
//}
//
//void CHalconWnd::ThreadFuncTestMatchModel(HObject imgCameraImage, HTuple* hvModelIDMatch, HObject* xldModelContour, HObject* xldContoursAffineTrans,
//	HTuple* hvContoursAffineTransRow, HTuple* hvContoursAffineTransColumn, HTuple* hvContoursAffineTransAngle)
//{
//	HTuple ShapeModelOrgRow, ShapeModelOrgCol;
//	HTuple NumLevels, AngleStart, AngleExtent, AngleStep, ScaleMin, ScaleMax, ScaleStep, Metric, MinContrast;
//
//	HTuple /*hv_Row, hv_Column, hv_Angle,*/ hv_Score;
//	HTuple	hv_HomMat2D;
//	//HObject  ho_ContoursAffineTrans;
//
//	try
//	{
//		ReadShapeModel(_T("./fff_hvModelID.shm"), &(*hvModelIDMatch));
//		GetShapeModelContours(&(*xldModelContour), (*hvModelIDMatch), 1);
//		GetShapeModelOrigin((*hvModelIDMatch), &ShapeModelOrgRow, &ShapeModelOrgCol);
//		GetShapeModelParams((*hvModelIDMatch), &NumLevels,
//			&AngleStart, &AngleExtent, &AngleStep,
//			&ScaleMin, &ScaleMax, &ScaleStep,
//			&Metric, &MinContrast);
//
//		//ReadImage(&m_hoShapeModelImage, "C://Users//Jason Zou//Desktop//CCD Sample//zzz_ImageROI.bmp");
//		//GetDomain(m_hoShapeModelImage, &m_hoDomainModelRegion);
//
//		FindShapeModel(imgCameraImage, (*hvModelIDMatch), 0, HTuple(360).TupleRad(),
//			0.6, 1, 0.8, "least_squares", 0, 0.9,
//			&(*hvContoursAffineTransRow), &(*hvContoursAffineTransColumn), &(*hvContoursAffineTransAngle), &hv_Score);
//		VectorAngleToRigid(0, 0, 0, (*hvContoursAffineTransRow), (*hvContoursAffineTransColumn), (*hvContoursAffineTransAngle), &hv_HomMat2D);
//		AffineTransContourXld((*xldModelContour), &(*xldContoursAffineTrans), hv_HomMat2D);
//		
//	}
//	catch (HException & exception)
//	{
//		AfxMessageBox(exception.ErrorMessage());
//		if ((int)exception.ErrorCode() < 0)
//			throw exception;
//	}
//	m_bTestMatchModel = FALSE;
//}

BOOL CHalconWnd::IsXldEmpty(HObject* hoXld)
{
	HTuple hvArea, hvRow, hvCol, hvPointOrder, hvLength, hvCount;

	try
	{
		if (FALSE == (*hoXld).IsInitialized())
		{
			return TRUE;
		}
		else
		{
			CountObj(*hoXld, &hvCount);
			if (0 == hvCount.I())
				return TRUE;

			AreaCenterXld((*hoXld), &hvArea, &hvRow, &hvCol, &hvPointOrder);
			TupleLength(hvArea, &hvLength);
			int i = hvLength.I();
			double dd = hvLength.D();
			if (0 == hvLength.I())
			{
				return TRUE;
			}
		}
	}
	catch (HException& exception)
	{
		AfxMessageBox((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());
		if ((int)exception.ErrorCode() < 0)
			throw exception;
	}

	return FALSE;
}

void CHalconWnd::TestFindCircleHand()
{
	if (m_bDrawingArea)
		return;
	m_bDrawingArea = TRUE;

	DrawCircleMod(m_hWindow, m_nImageHeight / 2, m_nImageWidth / 2, m_nImageWidth / 20, &m_hvDrawCircleRow, &m_hvDrawCircleColumn,
		&m_hvDrawCircleRadius);

	m_bDrawingArea = FALSE;
	m_bTestFindCircleHand = TRUE;
	m_bCameraMoveHand = FALSE;
}
void CHalconWnd::ThreadFuncTestFindCircleHand(HObject imgCameraImage, HObject* xldCircle, HTuple* hvParameterCircle)
{
	HObject  ho_Image, ho_ContCircle, ho_Contour;
	//HObject  ho_Contours;

	HTuple  hv_Row, hv_Column, hv_Radius, hv_Length1, hv_Length2;
	HTuple  hv_Sigme, hv_Threshold, hv_MetrologyHandle, hv_Index;
	HTuple  hv_Parameter, hv_Row1, hv_Column1, hv_message1;
	HTuple  hv_message2, hv_message3;
	HTuple	hv_MinScore;

	hv_MinScore = ReadDevCameraMarkCircleFindMinScore();
	ho_Image = imgCameraImage;

	try
	{

		hv_Row = m_hvDrawCircleRow;
		hv_Column = m_hvDrawCircleColumn;
		hv_Radius = m_hvDrawCircleRadius;

		GenCircleContourXld(&ho_ContCircle, hv_Row, hv_Column, hv_Radius, 0, 6.28318, "positive", 1);
		CreateMetrologyModel(&hv_MetrologyHandle);
		//AddMetrologyObjectGeneric(hv_MetrologyHandle, "circle", (hv_Row.TupleConcat(hv_Column)).TupleConcat(hv_Radius),
		//							20, 5, 1, 30, HTuple(), HTuple(), &hv_Index);
		AddMetrologyObjectCircleMeasure(hv_MetrologyHandle, hv_Row, hv_Column, hv_Radius,
										20, 5, 1.5, 10, HTuple(), HTuple(), &hv_Index);
		SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "measure_transition", "all");
		SetMetrologyObjectParam(hv_MetrologyHandle, hv_Index, "min_score", hv_MinScore);
		ApplyMetrologyModel(ho_Image, hv_MetrologyHandle);
		GetMetrologyObjectResult(hv_MetrologyHandle, "all", "all", "result_type", "all_param", &hv_Parameter);
		GetMetrologyObjectResultContour(&ho_Contour, hv_MetrologyHandle, "all", "all", 1.5);
		//GetMetrologyObjectMeasures(&ho_Contours, hv_MetrologyHandle, "all", "all", &hv_Row1, &hv_Column1);
	}
	catch (HException& exception)
	{
		//AfxMessageBox(exception.ErrorMessage());
		AfxMessageBox((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());
		if ((int)exception.ErrorCode() < 0)
			throw exception;
	}

	//if (IsXldEmpty(&ho_Contour))
		//TRACE("手动抓圆失败\n");
	//else
	//	TRACE("手动抓圆成功\n");

	*xldCircle = ho_Contour;
	*hvParameterCircle = hv_Parameter;
	m_bTestFindCircleHand = FALSE;
}
void CHalconWnd::DispTestFindCircleHand(HObject xldContourCircle, HTuple hvParameterCircle)
{
	HTuple hv_CenterRow, hv_CenterCol, hv_CircleRadius;
	HTuple hv_CenterX, hv_CenterY, hv_Radius;
	double fPixelSize;

	try
	{
		if (IsXldEmpty(&xldContourCircle))
		{
			return;
		}

		SetColor(m_hWindow, "red");
		DispObj(xldContourCircle, m_hWindow);
		SetColor(m_hWindow, "green");

		hv_CenterRow = HTuple(hvParameterCircle[0]);
		hv_CenterCol = HTuple(hvParameterCircle[1]);
		hv_CircleRadius = HTuple(hvParameterCircle[2]);
		//DispText(m_hWindow, (("CenterRow: " + hv_CenterRow).TupleConcat("CenterCol: " + hv_CenterCol)).TupleConcat("CircleRadius: " + hv_CircleRadius),
		//	"image", hv_CenterRow, hv_CenterCol, "black", HTuple(), HTuple());

		//计算圆的坐标位置及大小
		fPixelSize = ReadDevCameraPixelSize();
		hv_CenterX = hv_CenterCol - (m_nImageWidth / 2);
		hv_CenterY = hv_CenterRow - (m_nImageHeight / 2);
		hv_CenterY = -hv_CenterY;
		hv_CenterX *= fPixelSize;
		hv_CenterY *= fPixelSize;
		hv_Radius = hv_CircleRadius * fPixelSize;

		DispText(m_hWindow, (("CenterRow: " + hv_CenterRow).TupleConcat("CenterCol: " + hv_CenterCol)).TupleConcat("CircleRadius: " + hv_CircleRadius),
			"image", hv_CenterRow, hv_CenterCol, "black", HTuple(), HTuple());
		//DispText(m_hWindow, (("CenterX: " + hv_CenterX).TupleConcat("CenterY: " + hv_CenterY)).TupleConcat("Radius: " + hv_Radius),
		//					"image", hv_CenterRow, hv_CenterCol, "black", HTuple(), HTuple());

	}
	catch (HException& exception)
	{
		AfxMessageBox((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());
		if ((int)exception.ErrorCode() < 0)
			throw exception;
	}

	//if (FALSE == m_bCameraMoveHand)
	//{
	//	//工作台移动工
	//	TRACE("工作台移动\n");
	//	TRACE("x = %lf\n", hv_CenterX.D());
	//	TRACE("y = %lf\n", hv_CenterY.D());
	//	m_bCameraMoveHand = TRUE;
	//}

	//移动相机视场中心到圆中心
	if (NULL == pDevCardWorktable)
		return;
	if (FALSE == m_bCameraMoveHand)
	{
		pDevCardWorktable->PosMoveXYHand(hv_CenterX.D(), hv_CenterY.D());
		m_bCameraMoveHand = TRUE;
	}
}

BOOL CHalconWnd::AutoFindCircle(std::vector<CPointF>* vPtPos)
{
	//启动自动抓圆
	ResetEvent(hdFindDone);
	m_bTestFindCircles = TRUE;
	m_bCameraMove = TRUE;

	//等待抓圆结束
	WaitForFindDone();
	return GetPosFindCircles(vPtPos);
}

void CHalconWnd::WaitForFindDone()
{
	DWORD dRet;
	MSG msg;
	while (1)
	{
		dRet = MsgWaitForMultipleObjects(1, &hdFindDone, FALSE, INFINITE, QS_ALLINPUT);

		switch (dRet)
		{
		case WAIT_OBJECT_0:
			//抓圆结束
			TRACE("抓圆结束，函数返回值: %d \n", dRet);
			return;
		case WAIT_OBJECT_0 + 1:
			//收到消息
			TRACE("收到消息,函数返回值为%d \n", dRet);
			while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
			{
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
			//Sleep(1); //REDUCES CPU!			
			break;
		default:
			//非正常退出
			TRACE("非正常退出，函数返回值: %d \n", dRet);
			CString strTMp;
			strTMp.Format(_T("WaitForFindDone非正常退出，函数返回值: %d \n"), dRet);
			AfxMessageBox(strTMp);
			return;
		}
	}
}

void CHalconWnd::TestFindCircles()
{
	m_bTestFindCircles = TRUE;
	m_bCameraMove = FALSE;
}
void CHalconWnd::ThreadFuncTestFindCircles(HObject imgCameraImage, HObject* xldContourCircles, HTuple* hvParameterCircles)
{
	// Local iconic variables
	HObject  ho_ContCircleModel, ho_ContCircle;
	HObject  ho_Contours;
	HObject	 ho_ContCircleModelCentered, ho_ContCircleModelImage, ho_ContCircleModelRegion, ho_ContCircleModelRegionDilation, ho_ModelImage;

	// Local control variables
	HTuple  hv_Selection, hv_WindowHandle, hv_CircleRadiusPixel;
	HTuple	hv_Hom2d, hv_CircleImageHeight, hv_CircleImageWidth;
	HTuple  hv_ModelID, hv_Row, hv_Column, hv_Angle, hv_Scale;
	HTuple  hv_Score, hv_Length;
	HTuple	hv_Parameter, hv_CenterX, hv_CenterY, hv_Radius;
	HTuple	hv_FindedPoxX, hv_FindedPoxY;
	HTuple	hv_ScaleMin, hv_ScaleMax, hv_MinScore;

	hv_ScaleMin = ReadDevCameraMarkCircleFindScaleMin();
	hv_ScaleMax = ReadDevCameraMarkCircleFindScaleMax();
	hv_MinScore = ReadDevCameraMarkCircleFindMinScore();
	double fPixelSize = ReadDevCameraPixelSize();
	double fMarkCircleRadius = ReadDevCameraMarkCircleRadius();
	try
	{
		//WriteImage(imgCameraImage, "bmp", 0, _T("./imgCameraImage.bmp"));

		//生成模板圆图片，如果尺寸不变，就用原图
		hv_CircleRadiusPixel = fMarkCircleRadius / fPixelSize;	
		hv_CircleImageHeight = hv_CircleRadiusPixel * 2 + 10;
		hv_CircleImageWidth = hv_CircleRadiusPixel * 2 + 10;
		if (hv_CircleRadiusPixel != g_hvCircleRadiusPixel)
		{
			GenCircleContourXld(&ho_ContCircleModel, 0, 0, hv_CircleRadiusPixel, 0, 6.28318, "positive", 1);
			HomMat2dIdentity(&hv_Hom2d);
			HomMat2dTranslate(hv_Hom2d, hv_CircleImageHeight / 2, hv_CircleImageWidth / 2, &hv_Hom2d);
			AffineTransContourXld(ho_ContCircleModel, &ho_ContCircleModelCentered, hv_Hom2d);
			GenImageConst(&ho_ContCircleModelImage, "byte", hv_CircleImageWidth, hv_CircleImageHeight);
			PaintXld(ho_ContCircleModelCentered, ho_ContCircleModelImage, &ho_ContCircleModelImage, 255);
			Threshold(ho_ContCircleModelImage, &ho_ContCircleModelRegion, 10, 255);
			DilationRectangle1(ho_ContCircleModelRegion, &ho_ContCircleModelRegionDilation, 3, 3);
			ReduceDomain(ho_ContCircleModelImage, ho_ContCircleModelRegionDilation, &ho_ModelImage);
			//存抓标圆尺寸
			g_hvCircleRadiusPixel = hv_CircleRadiusPixel;
			g_hoModelCircleImage = ho_ModelImage;
		}

		CreateScaledShapeModel(g_hoModelCircleImage, "auto", -0.39, 0.79, "auto", hv_ScaleMin, hv_ScaleMax, "auto",
			"auto", "ignore_local_polarity", "auto", "auto", &hv_ModelID);
		//CreateScaledShapeModelXld(ho_ContCircleModel, "auto", -0.39, 0.79, "auto", hv_ScaleMin, hv_ScaleMax,
		//							"auto", "auto", "ignore_local_polarity", 5, &hv_ModelID);
		FindScaledShapeModel(imgCameraImage, hv_ModelID, -0.39, 0.78, hv_ScaleMin, hv_ScaleMax, hv_MinScore, 0, 0.1,
			"least_squares", 0, 0.9, &hv_Row, &hv_Column, &hv_Angle, &hv_Scale, &hv_Score);
		ClearShapeModel(hv_ModelID);

		GenEmptyObj(&ho_Contours);
		TupleGenConst(0, NULL, &hv_Parameter);
		TupleGenConst(0, NULL, &hv_FindedPoxX);
		TupleGenConst(0, NULL, &hv_FindedPoxY);

		TupleLength(hv_Row, &hv_Length);
		if (0 == hv_Length.I())
		{
			m_bTestFindCircles = FALSE;
			*xldContourCircles = ho_Contours;
			*hvParameterCircles = hv_Parameter;
			SetPosFindCircles(FALSE, 0, 0);
			//AfxMessageBox(_T("没找到Mark圆"));
			return;
		}

		HTuple end_val20 = hv_Length - 1;
		HTuple step_val20 = 1;
		HTuple hv_i, hv_ii;
		for (hv_i = 0; hv_i.Continue(end_val20, step_val20); hv_i += step_val20)
		{
			//concat圆轮廓
			GenCircleContourXld(&ho_ContCircle, HTuple(hv_Row[hv_i]), HTuple(hv_Column[hv_i]),
								hv_CircleRadiusPixel * HTuple(hv_Scale[hv_i]), 0, 6.28318, "positive", 1);
			ConcatObj(ho_Contours, ho_ContCircle, &ho_Contours);

			//计算圆的坐标位置及大小
			hv_ii = hv_i * 3;
			double fPixelSize;
			fPixelSize = ReadDevCameraPixelSize();
			hv_CenterX = HTuple(hv_Column[hv_i]) - (m_nImageWidth / 2);
			hv_CenterY = HTuple(hv_Row[hv_i]) - (m_nImageHeight / 2);
			hv_CenterY = -hv_CenterY;	//转换到标准坐标系
			hv_CenterX *= fPixelSize;
			hv_CenterY *= fPixelSize;
			hv_Radius = hv_CircleRadiusPixel * HTuple(hv_Scale[hv_i]) * fPixelSize;

			//显示参数：每个圆5个参数，按顺序：x移动距离，y移动距离，半径，row坐标，col坐标
			HalconCpp::TupleConcat(hv_Parameter, hv_CenterX, &hv_Parameter);
			HalconCpp::TupleConcat(hv_Parameter, hv_CenterY, &hv_Parameter);
			HalconCpp::TupleConcat(hv_Parameter, hv_Radius, &hv_Parameter);
			HalconCpp::TupleConcat(hv_Parameter, HTuple(hv_Row[hv_i]), &hv_Parameter);
			HalconCpp::TupleConcat(hv_Parameter, HTuple(hv_Column[hv_i]), &hv_Parameter);

			//运动参数：
			HalconCpp::TupleConcat(hv_FindedPoxX, hv_CenterX, &hv_FindedPoxX);
			HalconCpp::TupleConcat(hv_FindedPoxY, hv_CenterY, &hv_FindedPoxY);
			TRACE("抓到1个圆，Row,Col = (%lf, %lf) \n", HTuple(hv_Row[hv_i]).D(), HTuple(hv_Column[hv_i]).D());
			TRACE("抓到1个圆，X,Y = (%lf, %lf) \n", hv_CenterX.D(), hv_CenterY.D());
		}
	}
	catch (HException& exception)
	{
		AfxMessageBox((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());
		if ((int)exception.ErrorCode() < 0)
			throw exception;
	}

	*xldContourCircles = ho_Contours;
	*hvParameterCircles = hv_Parameter;
	SetPosFindCircles(TRUE, hv_FindedPoxX, hv_FindedPoxY);

	m_bTestFindCircles = FALSE;
}

//void CHalconWnd::ThreadFuncTestFindCircles(HObject imgCameraImage, HObject* xldContourCircles, HTuple* hvParameterCircles)
//{
//	// Local iconic variables
//	HObject  ho_Image, ho_ImageThreshold, ho_ImageConnection;
//	HObject  ho_ContoursRegion, ho_SelectedXLDs, ho_ContCircle;
//	HObject  ho_Contours;
//
//	// Local control variables
//	HTuple  hv_Row, hv_Column, hv_Radius;
//	HTuple  hv_StartPhi, hv_EndPhi, hv_PointOrder;
//	HTuple  hv_MetrologyHandle, hv_MetrologyCircleIndices, hv_Parameter;
//	try
//	{
//		WriteImage(imgCameraImage, "bmp", 0, _T("./imgCameraImage.bmp"));
//
//		ho_Image = imgCameraImage;
//		Threshold(ho_Image, &ho_ImageThreshold, 80, 255);
//		Connection(ho_ImageThreshold, &ho_ImageConnection);
//		GenContourRegionXld(ho_ImageConnection, &ho_ContoursRegion, "border");
//		SelectShapeXld(ho_ContoursRegion, &ho_SelectedXLDs, (HTuple("area").Append("circularity")),
//			"and", (HTuple(500).Append(0.6)), (HTuple(6000000).Append(1)));
//		FitCircleContourXld(ho_SelectedXLDs, "algebraic", -1, 0, 0, 3, 2, &hv_Row, &hv_Column,
//							&hv_Radius, &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);
//		GenCircleContourXld(&ho_ContCircle, hv_Row, hv_Column, hv_Radius, 0, 6.28318, "positive", 1);
//		//count_obj (ContCircle, Number)
//
//		CreateMetrologyModel(&hv_MetrologyHandle);
//		//add_metrology_object_generic (MetrologyHandle, 'circle', [Row, Column, Radius], 20, 5, 1, 30, [], [], Index)
//		AddMetrologyObjectCircleMeasure(hv_MetrologyHandle, hv_Row, hv_Column, hv_Radius,
//										20, 5, 1.5, 2, HTuple(), HTuple(), &hv_MetrologyCircleIndices);
//		//SetMetrologyObjectParam(hv_MetrologyHandle, hv_MetrologyCircleIndices, "num_instances", 2);
//		SetMetrologyObjectParam(hv_MetrologyHandle, hv_MetrologyCircleIndices, "min_score", 0.7);
//		ApplyMetrologyModel(ho_Image, hv_MetrologyHandle);
//		GetMetrologyObjectResult(hv_MetrologyHandle, "all", "all", "result_type", "all_param", &hv_Parameter);
//		GetMetrologyObjectResultContour(&ho_Contours, hv_MetrologyHandle, "all", "all", 1.5);
//		ClearMetrologyModel(hv_MetrologyHandle);
//	}
//	catch (HException& exception)
//	{
//		AfxMessageBox((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());
//		if ((int)exception.ErrorCode() < 0)
//			throw exception;
//	}
//
//	//if (IsXldEmpty(&ho_Contours))
//	//	TRACE("自动抓圆失败ho_Contours为空\n");
//	//else
//	//	TRACE("自动抓圆成功\n");
//
//
//	*xldContourCircles = ho_Contours;
//	*hvParameterCircles = hv_Parameter;
//
//	//if (IsXldEmpty(&(*xldContourCircles)))
//	//	TRACE("xldContourCircles为空\n");
//	//else
//	//	TRACE("xldContourCircles不为空\n");
//
//	m_bTestFindCircles = FALSE;
//}

void CHalconWnd::DispTestFindCircles(HObject xldContourCircles, HTuple hvParameterCircles)
{
	HTuple hvArea, hvRow, hvCol, hvPointOrder, hvLength;
	//HTuple hv_CenterRow, hv_CenterCol, hv_CircleRadius;
	HTuple hv_i, hv_ii, hv_Number;
	HTuple hv_CenterX, hv_CenterY, hv_Radius, hv_CenterRow, hv_CenterCol;

	try
	{

		if (IsXldEmpty(&xldContourCircles))
		{
			return;
		}

		SetColor(m_hWindow, "red");
		DispObj(xldContourCircles, m_hWindow);
		SetColor(m_hWindow, "green");

		CountObj(xldContourCircles, &hv_Number);
		HTuple end_val29 = hv_Number - 1;
		HTuple step_val29 = 1;
		for (hv_i = 0; hv_i.Continue(end_val29, step_val29); hv_i += step_val29)
		{
			hv_ii = hv_i * 5;
			hv_CenterX = HTuple(hvParameterCircles[hv_ii]);
			hv_CenterY = HTuple(hvParameterCircles[hv_ii + 1]);
			hv_Radius = HTuple(hvParameterCircles[hv_ii + 2]);
			hv_CenterRow = HTuple(hvParameterCircles[hv_ii + 3]);
			hv_CenterCol = HTuple(hvParameterCircles[hv_ii + 4]);

			//hv_CenterRow = HTuple(hvParameterCircles[hv_ii]);
			//hv_CenterCol = HTuple(hvParameterCircles[hv_ii + 1]);
			//hv_CircleRadius = HTuple(hvParameterCircles[hv_ii + 2]);
			////DispText(m_hWindow, (("CenterRow: " + hv_CenterRow).TupleConcat("CenterCol: " + hv_CenterCol)).TupleConcat("CircleRadius: " + hv_CircleRadius),
			////		"image", hv_CenterRow, hv_CenterCol, "black", HTuple(), HTuple());

			////计算圆的坐标位置及大小
			//double fPixelSize;
			//fPixelSize = ReadDevCameraPixelSize();
			//hv_CenterX = hv_CenterCol - (m_nImageWidth / 2);
			//hv_CenterY = hv_CenterRow - (m_nImageHeight / 2);
			//hv_CenterY = -hv_CenterY;
			//hv_CenterX *= fPixelSize;
			//hv_CenterY *= fPixelSize;
			//hv_Radius = hv_CircleRadius * fPixelSize;

			DispText(m_hWindow, (("CenterX: " + hv_CenterX).TupleConcat("CenterY: " + hv_CenterY)).TupleConcat("Radius: " + hv_Radius),
								"image", hv_CenterRow, hv_CenterCol, "black", HTuple(), HTuple());
		}
	}
	catch (HException& exception)
	{
		AfxMessageBox((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());
		if ((int)exception.ErrorCode() < 0)
			throw exception;
	}

	//if (1 == hv_Number)
	//{
	//	if (FALSE == m_bCameraMove)
	//	{
	//		if (IsXldEmpty(&xldContourCircles))
	//			TRACE("工作台xldContourCircles为空\n");
	//		else
	//			TRACE("工作台xldContourCircles不为空\n");

	//		//工作台移动工
	//		TRACE("工作台移动\n");
	//		TRACE("x = %lf\n", hv_CenterX.D());
	//		TRACE("y = %lf\n", hv_CenterY.D());
	//		m_bCameraMove = TRUE;
	//	}
	//}

	//显示完成后存坐标


	//如果只识别到一个圆则移动工作台
	if (NULL == pDevCardWorktable)
		return;
	if (1 == hv_Number)
	{
		if (FALSE == m_bCameraMove)
		{
			pDevCardWorktable->PosMoveXYHand(hv_CenterX.D(), hv_CenterY.D());
			m_bCameraMove = TRUE;
		}
	}

}


void CHalconWnd::SetPosFindCircles(BOOL bFlagFinded, HTuple hvPosX, HTuple hvPosY)
{
	m_bFlagFinded = bFlagFinded;

	if (FALSE == bFlagFinded)
	{
		m_hvFindedPosX = 0;
		m_hvFindedPosY = 0;
	}
	else
	{
		m_hvFindedPosX = hvPosX;
		m_hvFindedPosY = hvPosY;
	}
	SetEvent(hdFindDone);//抓圆结束
}
BOOL CHalconWnd::GetPosFindCircles(std::vector<CPointF>* vPtPos)
{
	//清空vector
	vPtPos->clear();

	if (FALSE == m_bFlagFinded)
		return FALSE;

	CPointF ptTmp;
	HTuple hvLength;
	TupleLength(m_hvFindedPosX, &hvLength);
	//vPtPos->resize((size_t)hvLength.I());
	for (HTuple hv_i = 0; hv_i < hvLength; hv_i += 1)
	{
		ptTmp.x = (FLOAT)HTuple(m_hvFindedPosX[hv_i]).D();
		ptTmp.y = (FLOAT)HTuple(m_hvFindedPosY[hv_i]).D();
		vPtPos->push_back(ptTmp);
	}
	return TRUE;
}

void CHalconWnd::ReverseImgColor(HObject imgInput, HObject* imgReversed)
{
	InvertImage(imgInput, &(*imgReversed));
}
void CHalconWnd::SetImgBrightness(HObject imgInput, HObject* imgBrighted, int nImgBrightness)
{
	ScaleImage(imgInput, &(*imgBrighted), 1, nImgBrightness);
}
void CHalconWnd::SetImgContrast(HObject imgInput, HObject* imgContrasted, int nImgContrast)
{

	// Local iconic variables
	HObject  ho_Rectangle;

	// Local control variables
	HTuple  hv_Width, hv_Height, hv_GMin, hv_GMax, hv_GDelta;
	HTuple  hv_Range, hv_Mult, hv_Add;

	if (0 == nImgContrast)
		return;

	try {
		GetImageSize(imgInput, &hv_Width, &hv_Height);
		GenRectangle1(&ho_Rectangle, 0, 0, hv_Height, hv_Width);
		MinMaxGray(ho_Rectangle, imgInput, 0, &hv_GMin, &hv_GMax, &hv_Range);
		//hv_Mult = 255 / (hv_GMax - hv_GMin);
		//hv_Add = (-hv_Mult) * hv_GMin;
		//hv_Mult = (((255 / (hv_GMax - hv_GMin)) - 1) * nImgContrast / 255) + 1;
		//hv_Add = - (hv_GMin / (hv_GMax - hv_GMin)) * nImgContrast;
		hv_GDelta = hv_GMax - hv_GMin;
		hv_Mult = (hv_GDelta + nImgContrast / 255 * (255 - hv_GDelta)) / hv_GDelta;
		hv_Add =  - hv_Mult * hv_GMin;

		ScaleImage(imgInput, &(*imgContrasted), hv_Mult, hv_Add);

	}
	catch (HException& exception)
	{
		//AfxMessageBox((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());
		TRACE((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());

		if ((int)exception.ErrorCode() < 0)
			throw exception;
	}

}

HImage CHalconWnd::GetImageDisplay()
{
	HImage hoImg;
	EnterCriticalSection(&resultDataMutex);      // CriticalSect
	hoImg = m_hoImageDisplay;
	LeaveCriticalSection(&resultDataMutex);      // CriticalSect

	return hoImg;

}
BOOL CHalconWnd::ClearContourMask()
{
	GenEmptyObj(&m_hoContourMask);
	return TRUE;
}
BOOL CHalconWnd::SetContourMask(HObject hoContour)
{
	m_hoContourMask = hoContour;
	return TRUE;
}
BOOL CHalconWnd::MoveContourMask(HTuple hvTransX, HTuple hvTransY, HTuple hvRotate)
{
	HTuple hv_Width, hv_Height, hv_CameraX, hv_CameraY, hv_PixelSize;
	HTuple hv_RowCenter, hv_ColumnCenter;
	HTuple hv_HomMat2D, hv_HomMat2DTranslate, hv_HomMat2DRotate, hv_HomMat2DTrans;
	HTuple hv_PosX, hv_PosY;
	HTuple hv_TransPixelX, hv_TransPixelY;
	HTuple hv_RowOrg, hv_ColumnOrg, hv_AngleOrg;
	try
	{
		if (IsXldEmpty(&m_hoContourMask))
			return FALSE;

		hv_Width = m_nImageWidth;
		hv_Height = m_nImageHeight;
		hv_PixelSize = ReadDevCameraPixelSize();
		hv_CameraX = ReadDevCameraPosX();
		hv_CameraY = ReadDevCameraPosY();
		hv_CameraX = hv_CameraX / hv_PixelSize;
		hv_CameraY = hv_CameraY / hv_PixelSize;
		hv_CameraY = -hv_CameraY;
		hv_RowCenter = hv_Height / 2 - hv_CameraY;
		hv_ColumnCenter = hv_Width / 2 - hv_CameraX;

		hv_PosX = g_ptDxfTranslate.x;
		hv_PosY = g_ptDxfTranslate.y;
		hv_PosX = hv_PosX / hv_PixelSize;
		hv_PosY = hv_PosY / hv_PixelSize;
		hv_PosY = -hv_PosY;
		hv_RowOrg = hv_RowCenter + hv_PosY;
		hv_ColumnOrg = hv_ColumnCenter + hv_PosX;
		hv_AngleOrg = 0;

		hv_TransPixelX = hvTransX / hv_PixelSize;
		hv_TransPixelY = hvTransY / hv_PixelSize;
		hv_TransPixelY = -hv_TransPixelY;

		VectorAngleToRigid(hv_RowOrg, hv_ColumnOrg, hv_AngleOrg.TupleRad(), hv_RowOrg + hv_TransPixelY, hv_ColumnOrg + hv_TransPixelX, (hv_AngleOrg+hvRotate).TupleRad(), &hv_HomMat2D);
		AffineTransContourXld(m_hoContourMask, &m_hoContourMask, hv_HomMat2D);
		
		//HomMat2dIdentity(&hv_HomMat2D);
		//HomMat2dRotate(hv_HomMat2D, hvRotate.TupleRad(), hv_RowCenter, hv_ColumnCenter, &hv_HomMat2DRotate);
		//HomMat2dTranslate(hv_HomMat2DRotate, hvTransY, hvTransX, &hv_HomMat2DTranslate);
		//AffineTransContourXld(m_hoContourMask, &m_hoContourMask, hv_HomMat2DTranslate);
	}
	catch (HException& exception)
	{
		AfxMessageBox((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());
		TRACE((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());

		if ((int)exception.ErrorCode() < 0)
			throw exception;

		return FALSE;
	}

	g_ptDxfTranslate.x += hvTransX.D();
	g_ptDxfTranslate.y += hvTransY.D();
	g_fDxfRotate += hvRotate.D();

	return TRUE;
}
BOOL CHalconWnd::ClearStringMask()
{
	m_bShowString = FALSE;
	m_hvString.Clear();
	m_hvStringRow = 0;
	m_hvStringColumn = 0;
	return TRUE;
}
BOOL CHalconWnd::SetStringMask(HTuple hvString, HTuple hvRow, HTuple hvColumn)
{
	m_bShowString = TRUE;
	m_hvString = hvString;
	m_hvStringRow = hvRow;
	m_hvStringColumn = hvColumn;

	return TRUE;
}
void CHalconWnd::ShowStringMask()
{
	//约定每个对象显示三行信息
	if (FALSE == m_bShowString)
		return;

	HTuple hv_Length;
	TupleLength(m_hvStringRow, &hv_Length);
	for (HTuple hv_i = 0; hv_i.Continue(hv_Length - 1, 1); hv_i += 1)
	{
		DispText(m_hWindow, m_hvString[hv_i * 3] + "\n" + m_hvString[hv_i * 3 + 1] + "\n" + m_hvString[hv_i * 3 + 2], "image", m_hvStringRow[hv_i], m_hvStringColumn[hv_i], "black", HTuple(), HTuple());
	}
}


int CHalconWnd::LocateModel(HalconModel& modelHalcon, std::vector<CPointF>* vPtPos, BOOL bShowModelCotour, BOOL bShowModelString)
{
	HObject	hoImageDisplay, hoModelContour, hoModelContourAffine;

	HTuple hv_Class, hv_ModelID;
	HTuple hv_ScaleMin, hv_ScaleMax, hv_ModelOriginRow, hv_ModelOriginColumn, hv_MinScore;
	HTuple hv_Row, hv_Column, hv_Angle, hv_Scale, hv_Score, hv_Length;
	HTuple HomMat2D;
	HTuple hv_PosX, hv_PosY, hv_String;

	try 
	{
		ClearContourMask();
		ClearStringMask();
		hoImageDisplay = GetImageDisplay();
		hoModelContour = modelHalcon.m_hoXldModel;
		hv_ScaleMin = modelHalcon.m_hvModelScaleMin;
		hv_ScaleMax = modelHalcon.m_hvModelScaleMax;
		hv_ModelOriginRow = modelHalcon.m_hvModelOriginRow;
		hv_ModelOriginColumn = modelHalcon.m_hvModelOriginColumn;
		hv_MinScore = modelHalcon.m_hvModelMinScore;

		//是否需要局部抓图


		//抓标
		GetObjClass(hoModelContour, &hv_Class);
		if (hv_Class == HTuple("image"))
			CreateScaledShapeModel(hoModelContour, "auto", -0.39, 0.79, "auto", hv_ScaleMin, hv_ScaleMax,
				"auto", "auto", "ignore_local_polarity", "auto", "auto", &hv_ModelID);
		else
			CreateScaledShapeModelXld(hoModelContour, "auto", -0.39, 0.79, "auto", hv_ScaleMin, hv_ScaleMax,
				"auto", "auto", "ignore_local_polarity", 5, &hv_ModelID);
		SetShapeModelOrigin(hv_ModelID, hv_ModelOriginRow, hv_ModelOriginColumn);
		GetShapeModelContours(&hoModelContour, hv_ModelID, 1);
		FindScaledShapeModel(hoImageDisplay, hv_ModelID, -0.39, 0.79, hv_ScaleMin, hv_ScaleMax, hv_MinScore, 0, 0.1,
			"least_squares", 0, 0.9, &hv_Row, &hv_Column, &hv_Angle, &hv_Scale, &hv_Score);
		ClearShapeModel(hv_ModelID);

		TupleLength(hv_Row, &hv_Length);
		if (0 == hv_Length.I())
		{
			vPtPos->clear();
			//AfxMessageBox(_T("没有找到模板"));
			return 0;
		}
		else if (1 < hv_Length.I())
		{
			//AfxMessageBox(_T("找到多个模板"));
			return hv_Length.I();
		}
		else if (1 == hv_Length.I())
		{
			//回传抓标轮廓
			if (bShowModelCotour)
			{
				HomMat2dIdentity(&HomMat2D);
				HomMat2dScale(HomMat2D, hv_Scale, hv_Scale, 0, 0, &HomMat2D);
				HomMat2dRotate(HomMat2D, hv_Angle, 0, 0, &HomMat2D);
				HomMat2dTranslate(HomMat2D, hv_Row, hv_Column, &HomMat2D);
				AffineTransContourXld(hoModelContour, &hoModelContourAffine, HomMat2D);
				SetContourMask(hoModelContourAffine);
			}

			//回传抓标坐标
			double fPixelSize;
			fPixelSize = ReadDevCameraPixelSize();
			hv_PosX = (hv_Column - m_nImageWidth / 2) * (HTuple)fPixelSize;
			hv_PosY = (hv_Row - m_nImageHeight / 2) * (HTuple)fPixelSize;
			hv_PosY = -hv_PosY;
			vPtPos->clear();
			vPtPos->push_back(CPointF(hv_PosX.D(), hv_PosY.D()));

			////回传抓标文字信息
			if (bShowModelString)
			{
				hv_String = ((("X: " + hv_PosX).TupleConcat("Y: " + hv_PosY)).TupleConcat("Angle: " + hv_Angle.TupleDeg())).TupleConcat("Scale: " + hv_Scale);
				SetStringMask(hv_String, hv_Row, hv_Column);
			}
			//hv_PosX = (hv_Column - m_hvImageWidth / 2) * (HTuple)fPixelSize;
			//hv_PosY = (hv_Row - m_hvImageHeight / 2) * (HTuple)fPixelSize;
			//hv_PosY = -hv_PosY;
			//DispText(m_hWindow, ((("PosX: " + hv_PosX).TupleConcat("PosY: " + hv_PosY)).TupleConcat("Angle: " + hv_Angle.TupleDeg())).TupleConcat("Scale: " + hv_Scale),
			//	"image", hv_Row + 3, hv_Column + 3, "black", HTuple(), HTuple());

			return 1;
		}
	}
	catch (HException& exception)
	{
		//AfxMessageBox((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());
		TRACE((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());

		if ((int)exception.ErrorCode() < 0)
			throw exception;
	}

	return -1;
}



afx_msg LRESULT CHalconWnd::OnGetImage(WPARAM wParam, LPARAM lParam)
{
	*(HObject*)wParam = GetImageDisplay();

	return 0;
}


afx_msg LRESULT CHalconWnd::OnShowContour(WPARAM wParam, LPARAM lParam)
{
	BOOL bShow = FALSE;
	bShow = (BOOL)wParam;

	if (FALSE == bShow)
		ClearContourMask();
	else
	{
		HObject hoContourAffined = *((HObject*)lParam);
		SetContourMask(hoContourAffined);
	}

	return 0;
}


afx_msg LRESULT CHalconWnd::OnShowText(WPARAM wParam, LPARAM lParam)
{
	BOOL bShow = FALSE;
	bShow = (BOOL)wParam;

	if (FALSE == bShow)
		ClearStringMask();
	else
	{
		//解析hvMixedText：如其长度为4N，则String:Row:Col = 2N:N:N
		HTuple hvMixedText = *((HTuple*)lParam);
		HTuple hvString, hvRow, hvCol;
		HTuple hvLength, hvLengthBy5, hvI;
		
		hvString = HTuple();
		hvRow = HTuple();
		hvCol = HTuple();
		TupleLength(hvMixedText, &hvLength);
		hvLengthBy5 = hvLength / 5;
		for (hvI = 0; hvI.Continue(3 * hvLengthBy5 - 1, 1); hvI += 1)
		{
			TupleConcat(hvString, hvMixedText[hvI], &hvString);
		}
		for (hvI = 3 * hvLengthBy5; hvI.Continue(4 * hvLengthBy5 - 1, 1); hvI += 1)
		{
			TupleConcat(hvRow, hvMixedText[hvI], &hvRow);
		}
		for (hvI = 4 * hvLengthBy5; hvI.Continue(hvLength - 1, 1); hvI += 1)
		{
			TupleConcat(hvCol, hvMixedText[hvI], &hvCol);
		}

		SetStringMask(hvString, hvRow, hvCol);
	}

	return 0;
}


BOOL CHalconWnd::ShowDxfContourMask(CString strPath)
{
	HObject hoContours, ContoursAffineTrans, hoRectangle;
	HTuple hv_Row1, hv_Row2, hv_Column1, hv_Column2, hv_RowMin, hv_RowMax, hv_ColumnMin, hv_ColumnMax;
	HTuple hv_RowCenter, hv_ColumnCenter, hv_Area, hv_PointOrder;
	HTuple hv_HomMat2D, hv_HomMat2DReflect, hv_HomMat2DScale, hv_HomMat2DTrans;
	HTuple hv_Height, hv_Width, hv_Scale, hv_Status, hv_CameraX, hv_CameraY;

	try
	{
		ReadContourXldDxf(&hoContours, (HString)strPath, HTuple(), HTuple(), &hv_Status);
		hv_Width = m_nImageWidth;
		hv_Height = m_nImageHeight;
		hv_Scale = 1 / ReadDevCameraPixelSize();
		hv_CameraX = ReadDevCameraPosX();
		hv_CameraY = ReadDevCameraPosY();
		hv_CameraX *= hv_Scale;
		hv_CameraY *= hv_Scale;
		hv_CameraY = -hv_CameraY;

		SmallestRectangle1Xld(hoContours, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
		TupleMin(hv_Row1, &hv_RowMin);
		TupleMax(hv_Row2, &hv_RowMax);
		TupleMin(hv_Column1, &hv_ColumnMin);
		TupleMax(hv_Column2, &hv_ColumnMax);
		GenRectangle2ContourXld(&hoRectangle, (hv_RowMin + hv_RowMax) / 2, (hv_ColumnMin + hv_ColumnMax) / 2, 0,
								hv_ColumnMax - hv_ColumnMin, hv_RowMax - hv_RowMin);
		AreaCenterXld(hoRectangle, &hv_Area, &hv_RowCenter, &hv_ColumnCenter, &hv_PointOrder);

		HomMat2dIdentity(&hv_HomMat2D);
		HomMat2dReflect(hv_HomMat2D, hv_RowCenter + 0.5, 0, hv_RowCenter + 0.5, hv_ColumnCenter, &hv_HomMat2DReflect);
		HomMat2dScale(hv_HomMat2DReflect, hv_Scale, hv_Scale, hv_RowCenter + 0.5, hv_ColumnCenter + 0.5, &hv_HomMat2DScale);
		HomMat2dTranslate(hv_HomMat2DScale, hv_Height / 2 - hv_RowCenter - hv_CameraY, hv_Width / 2 - hv_ColumnCenter - hv_CameraX, &hv_HomMat2DTrans);
		AffineTransContourXld(hoContours, &ContoursAffineTrans, hv_HomMat2DTrans);
		ClearStringMask();
		SetContourMask(ContoursAffineTrans);
	}
	catch (HException& exception)
	{
		AfxMessageBox((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());
		TRACE((HString)exception.ProcName() + (CString)_T("\n") + (HString)exception.ErrorMessage());

		if ((int)exception.ErrorCode() < 0)
			throw exception;

		return FALSE;
	}

	g_ptDxfTranslate = CPointF();
	g_fDxfRotate = 0;

	return TRUE;
}
